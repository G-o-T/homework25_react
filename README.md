# homework25_react

## 1. В компонент передаются атрибуты `description` и `title` . Могу ли я их сложить как на примере, чтобы получить одну строку и вывести в компоненте?
    
    ```jsx
    import React from "react";
    import styles from './button.css'
    
    export default class Example extends React.Component {
        render() {
    				let {description,title} = this.props
    				title += description; //title = title + description
             return (
                <span>{title}</span>
            );
        }
    }
    ```

Я попробовала на функциональном компоненте, все получилось. Делаю вывод, что и в примере выше получится. Но на сколько я понимаю, суть в том, чтобы пропсы были неиммутабельны (неизменяемы). Поэтому лучше через стэйт назначить новый тайтл


## 2. С помощью какого метода можно отловить изменение `props`?

shouldComponentUpdate(). Он получает, в частности, nextProps и выполняет сравнение с текущим значением props.

## 3. Оператор расширения часто используется также для клонирования объекта. Подумайте, чем отличаются эти две записи и какую проблему решает здесь оператор расширения:
    
    ```jsx
    const initialObj = { title:'Hello', text:'World' }
    
    //№1
    const firstObj = initialObj
    
    //№2
    const secondObj = {...initialObj}
    ```
    
Объекты - являются ссылочными значениями, т.е. мы не можем клонировать объект через "=" (мы получим не значение, а ссылку (указатель) на значение в памяти). А вот через spread объект как раз-таки можно клонировать. Но копия получится неглубокой, т.е. не будут скопированы вложенные объекты или массивы.

## 4. В каком из методов жизненного цикла лучше всего использовать методы вызова API и обращения к веб-хранилищам, если они должны быть вызваны всего один раз при загрузке страницы?

На этапе монтажа (mounting)

## 5. С помощью какого метода можно отловить и отрисовать для пользователя возникшую в компоненте ошибку?

componentDidCatch(error, info)
где error - перехваченная ошибка, info - содержит информация о компоненте, в котором произошла ошибка

## 6. Какой код обычно пишут в конструкторе? Для каких задач он используется?

Конструктор обычно используется для двух целей:
1) чтобы иницилизировать внутреннее состояниее через присвоение объекта this.state;
2) чтобы привязать обработчик событий к экземпляру

пример конструктора:
constructor(props) {
  super(props);
  this.state = { counter: 0 };
  this.handleClick = this.handleClick.bind(this);
}

## 7. Что делает функция `render`()? Что может её вызвать?

Render() используется, чтобы отображать компоненты на странице. Он возвращает React-элемент, который описывает, как должен выглядеть компонент на странице. В первый раз render вызывается корневым компонентом. В последующем (по словам из конспекта) - по разным причинам, например, обновление состояния компонента, перерисовка родительского компонента, перехват ошибки и т.д.

## 8. Что нужно изменить в коде из урока (видео), чтобы начальные параметры у компонента приходили из пропсов, но если пропсы вообще не заданы, начальные значения были инициализированы нулями?

Об этом говорится в видео "Неделя 29. Инициализация и моунтинг"?
Думаю, в таком случае можно воспользовать пропсами по умолчанию. Если правильно поняла, про какой код речь, то вариант такой:

Timer.defaultProps = {minutes: 0, seconds: 0};

## 9. Можно ли несколько раз использовать хук `useEffect` внутри одного компонента?

Да, можно. Например, можно использоваь несколько useEffect для разных задач. Это позволит сохранить код читабельным.

## 10. Можно ли не передавать второй аргумент в хук `useEffect`? Что тогда произойдёт?

Можно, в таком случае колбэк будет выполняться на каждом рендере. Последствия при этом будут завить от того, что "происходит" в колбэке. Если состояние не меняется, все ок. Если согласно колбэку состояние меняется, то создатся бесконечный цикл рендерингов (т.к. смена состояния вызывает рендер и колбэк срабатывает на каждом рендере)

## 11. Что означает возвращение функции в теле хука `useEffect`? 

Возвращение функции в теле хука useEffect означает, что эта функция будет выполнена при размонтировании компонента или при следующем вызове эффекта.

Когда компонент размонтируется или хук useEffect будет вызван снова (например, если какие-то зависимости изменились), предыдущий эффект будет сначала очищен, а затем выполнена функция, которая была возвращена из предыдущего вызова хука useEffect.

Это может быть полезно для выполнения некоторых очисточных операций, таких как отписка от событий, отмена запросов или очистка ресурсов. Возвращаемая функция будет вызываться перед выполнением нового эффекта или перед размонтированием компонента.

## 12. Будут ли перерисованы дочерние элементы компонента при вызове метода `forceUpdate`()?

Да, при вызове метода forceUpdate() в React все дочерние элементы компонента будут перерисованы. Этот принуждает компонент обновиться, даже если не было изменений. При этом использование forceUpdate() рассматривается как плохая практика в React